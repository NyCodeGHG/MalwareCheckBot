package de.nycode.malwarecheckbot.filtering.caching

import de.nycode.malwarecheckbot.filtering.safebrowsing.ThreatMatch
import io.ktor.util.InternalAPI
import io.ktor.util.encodeBase64
import io.lettuce.core.api.coroutines.RedisCoroutinesCommands
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import kotlin.time.Duration

/**
 * [MalwareCache] implementation using Redis.
 * Urls are used as Keys and the [ThreatMatch]es are stored as json inside the db.
 */
@OptIn(InternalAPI::class)
class RedisMalwareCache(private val redisConnection: RedisCoroutinesCommands<String, String>) : MalwareCache {

    private val json = Json {
        ignoreUnknownKeys = true
    }

    override suspend fun checkUrl(url: String): ThreatCacheValue? {
        val cachedJson = redisConnection.get(url.encodeBase64()) ?: return null
        return json.decodeFromString<ThreatCacheValue>(cachedJson)
    }

    override suspend fun save(
        url: String,
        value: ThreatCacheValue,
        duration: Duration
    ) {
        redisConnection.setex(
            url.encodeBase64(),
            duration.inWholeSeconds,
            json.encodeToString(value.copy(fromCache = true))
        )
    }
}
